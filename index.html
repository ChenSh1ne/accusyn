<!DOCTYPE html>

<!--
A web-based genome synteny browser

Name: Jorge Nunez Siri
NSID: jdn766
Student ID: 11239727
-->

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>A web-based genome synteny browser</title>
  <script type="text/javascript" src="circos.js"></script>
  <script type="text/javascript" src="d3.js"></script>
  <script type="text/javascript" src="d3-scale-chromatic.js"></script>
  <script type="text/javascript" src="d3-queue.js"></script>

  <script type="text/javascript" src="lodash.js"></script>
  <style type="text/css">
    #form-config p {
      color: black;
    }

    #form-config p.disabled {
      color: gainsboro;
    }

    input[type="range"],
    input[type="button"],
    button {
      cursor: pointer;
    }

    p.filter-connections:nth-child(1),
    p.filter-connections:nth-child(2),
    p.filter-connections:nth-child(3) {
      display: inline-block;
      margin: 0;
    }

    p.filter-connections:nth-child(2),
    p.filter-connections:nth-child(3) {
      margin: 0 0 0 10px;
    }
  </style>
</head>

<body>
  <div id="config" style="display: none; float: left">
    <h3>Chromosomes</h3>
    <p>
      <label for="nAngle" style="display: inline-block; text-align: left; width: 90px">
        Rotate = <span id="nAngle-value">…</span>
      </label>
      <input type="range" min="0" max="360" id="nAngle" style="width: 145px">
    </p>
    <form id="form-config"></form>
  </div>

  <script type="text/javascript">
    var blockDictionary = {}; // Dictionary to store the data for all blocks
    var connectionDictionary = {}; // Dictionary to store the data for all the connections between any source and target
    var dataChromosomes = []; // Array that stores the current chromosomes in the circos plot
    var dataChords = []; // Array that stores the plotting information for each block chord
    var geneDictionary = {}; // Dictionary that includes the start and end position data for each gene
    var gffKeys = []; // Array that includes the sorted keys from the gff dictionary
    var gffPositionDictionary = {}; // Dictionary that includes the start and end position data for each chromosome
    var selectedCheckbox = []; // Array that stores the value of selected checkboxes

    var myCircos; // Circos variable
    var svg; // Circos svg
    var width = 800; // Circos plot width
    var height = 800; // Circos plot height

    var chromosomeRotateAngle = 0; // Default rotating angle for the genome view
    var colors = d3.scaleOrdinal(d3.schemeSet2); // Default color scheme
    var connectionColor = "sandybrown"; // Default connection color
    var collinearityFile; // To store the data from the collinearity file
    var currentSelectedBlock = {}; // To store the data of the current selected block
    var filterValue = 1; // Default filtering value
    var filterSelect = 'At Least'; // Default filtering select
    var showAllChromosomes = true; // To keep track of the Show All input state

    /**
     * Fixes current IDs in collinearity file by removing 0 when
     * chromosome number is below 10 (e.g. (N09,N01) turns into (N9, N1))
     *
     * @param  {Object} collinearityFile All the similarity relationships
     * @param  {number} index            Current index
     * @return {Object}                  Object with sourceID and targetID fixed
     */
    function fixSourceTargetCollinearity(collinearityFile, index) {
      var sourceID = collinearityFile[index].source.split('g')[0].split('Bna')[1];
      var targetID = collinearityFile[index].target.split('g')[0].split('Bna')[1];
      if (sourceID[1] == '0') {
        sourceID = sourceID.slice(0, 1) + sourceID.slice(2);
      }
      if (targetID[1] == '0') {
        targetID = targetID.slice(0, 1) + targetID.slice(2);
      }

      return {
        source: sourceID,
        target: targetID
      }
    }

    /**
     * Uses the current connection dictionary to find a connection with the
     * source and target
     *
     * @param  {Object} dictionary Current dictionary
     * @param  {string} source     Current source
     * @param  {string} target     Current target
     * @return {Object}            Value of the first target that has a
     *                             connection with the source
     */
    function findBlockConnection(dictionary, source, target) {
      return dictionary[source].find(function(element) {
        return element.connection == target;
      });
    }

    /**
     * Uses the current connection dictionary to find an index of a connection
     * between the source and target
     *
     * @param  {Object} dictionary Current dictionary
     * @param  {string} source     Current source
     * @param  {string} target     Current target
     * @return {number}            Array index of the first target that
     *                             has a connection with the source
     */
    function findIndexConnection(dictionary, source, target) {
      return dictionary[source].findIndex(function(element) {
        return element.connection == target;
      });
    }

    /**
     * Looks for minimum and maximum positions within the current block
     *
     * @param  {string} block Current block
     * @return {Object}       Resulting block min and max information
     */
    function lookForBlocksPositions(block) {
      var blockArray = blockDictionary[block];

      var maxSource = 0;
      var minSource = 100000000;
      var maxTarget = 0;
      var minTarget = 100000000;
      for (var i = 0; i < blockArray.length; i++) {
        var currentSource = geneDictionary[blockArray[i].source];
        var currentTarget = geneDictionary[blockArray[i].target];

        minSource = Math.min(minSource, currentSource.start);
        maxSource = Math.max(maxSource, currentSource.end);

        minTarget = Math.min(minTarget, currentTarget.start);
        maxTarget = Math.max(maxTarget, currentTarget.end);
      }

      return {
        blockLength: blockArray.length,
        minSource: minSource,
        maxSource: maxSource,
        minTarget: minTarget,
        maxTarget: maxTarget
      }
    }

    /**
     * Generates all paths in the genomeView using the current selected
     * chromosomes and the configuration
     *
     * @return {undefined} undefined
     */
    function generatePathGenomeView() {
      dataChords = []; // Emptying data chords array

      var foundCurrentSelectedBlock = false;

      var visited = {}; // Visited block dictionary
      Object.keys(blockDictionary).forEach(function(d) {
        visited[d] = false;
      });

      var oneToMany = selectedCheckbox.length == 1;
      var lookID = [];
      if (oneToMany) {
        // One to many relationships
        lookID.push(selectedCheckbox[0]);
      } else {
        // Many to many relationships
        for (var j = 0; j < selectedCheckbox.length; j++) {
          lookID.push(selectedCheckbox[j]);
        }
      }

      for (var i = 0; i < collinearityFile.length; i++) {
        if (collinearityFile[i].source.includes('N') && collinearityFile[i].target.includes('N')) {

          var IDs = fixSourceTargetCollinearity(collinearityFile, i);
          var sourceID = IDs.source;
          var targetID = IDs.target;

          var shouldAddDataChord = false;
          if (oneToMany) {
            // For one to many
            // Either the source or the target needs to be currently selected
            // Unless Show All is not selected meaning that both source and target
            // need to be the same selected chromosome
            shouldAddDataChord = showAllChromosomes ?
              (lookID.indexOf(sourceID) > -1 || lookID.indexOf(targetID) > -1) :
              (lookID.indexOf(sourceID) > -1 && lookID.indexOf(targetID) > -1);
          } else {
            // For many to many all connections need to be between selected chromosomes
            shouldAddDataChord = lookID.indexOf(sourceID) > -1 && lookID.indexOf(targetID) > -1;
          }

          var currentBlock = collinearityFile[i].block;
          if (!visited[currentBlock]) {
            // Only need to enter the very first time each block is visited
            visited[currentBlock] = true;

            // Only add data chord if the filter condition is satisfied
            shouldAddDataChord = shouldAddDataChord && (
              (filterSelect === 'At Least' && blockDictionary[currentBlock].length >= filterValue) ||
              (filterSelect === 'At Most' && blockDictionary[currentBlock].length <= filterValue)
            );

            if (shouldAddDataChord) {
              var blockPositions = lookForBlocksPositions(currentBlock);
              dataChords.push({
                source: {
                  id: sourceID,
                  start: blockPositions.minSource,
                  end: blockPositions.maxSource,
                  value: {
                    id: currentBlock,
                    length: blockPositions.blockLength,
                  }
                },
                target: {
                  id: targetID,
                  start: blockPositions.minTarget,
                  end: blockPositions.maxTarget
                }
              });

              if (_.isEqual(dataChords[dataChords.length - 1], currentSelectedBlock)) {
                foundCurrentSelectedBlock = true;
              }
            }
          }
        }
      }

      // Remove block view if selected block is not present anymore
      if (!foundCurrentSelectedBlock &&
        !d3.select("body").select("#block-view-container").empty()) {
        d3.select("body").select("#block-view-container").remove();
      }

      // Adding the configuration for the circos chords using the generated array
      myCircos.chords('chords', dataChords, {
        radius: null,
        logScale: false,
        opacity: 0.7,
        color: connectionColor,
        tooltipContent: function(d) {
          return '<h4>' + d.source.id + ' ➤ ' + d.target.id + '</h4>' +
            '<h4><u>Block information</u></h4>' +
            '<h4>ID: ' + d.source.value.id + '</h4>' +
            '<h4>Length: ' + d.source.value.length + '</h4>';
        },
        events: {
          'mouseover.block': function(d, i, nodes) {
            currentSelectedBlock = d;

            d3.selectAll(nodes).attr("opacity", 0.7);

            if (d3.selectAll(nodes).attr("opacity") != 0.35) {
              d3.selectAll(nodes).attr("opacity", 0.35);
              d3.select(nodes[i]).attr("opacity", 0.9);
            }

            // Showing block view for current block
            generateBlockView(d);
          }
        }
      });

      // Rendering circos plot with current configuration
      myCircos.render();

      d3.select(".block-number-headline")
        .text(function() {
          var blockSize = dataChords.length.toString();
          var textToShow = "Showing ";
          textToShow += blockSize === "1" ? (blockSize + " block") : (blockSize + " blocks");
          return textToShow;
        });
    }

    /**
     * Updates the angle of the genome view
     *
     * @param  {number} nAngle Current angle between 0 and 360
     * @return {undefined}     undefined
     */
    function updateAngle(nAngle) {
      chromosomeRotateAngle = nAngle;

      // Adjust the text on the rotating range slider
      d3.select("#nAngle-value").text(nAngle + String.fromCharCode(176));
      d3.select("#nAngle").property("value", nAngle);

      // Rotate the text
      svg.select(".all")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ") rotate(" + -nAngle + ")");
    }

    /**
     *  Updates the filter range value
     *
     * @param  {number} value             Filtering value
     * @param  {boolean} shouldUpdatePath True if should update paths in genome
     *                                    view, false otherwise
     * @return {undefined}                undefined
     */
    function updateFilter(value, shouldUpdatePath) {
      filterValue = value;

      // Adjust the text on the filter range slider
      d3.select("#filter-value").text(value == 1 ? value + " connection" : value + " connections");
      d3.select("#filter").property("value", value);

      if (shouldUpdatePath) generatePathGenomeView();
    }

    /**
     * Generates and preprocess data for the syteny browser
     *
     * @param  {Object} error               Error handler
     * @param  {Array<Object>} gff          Data from gff file
     * @param  {Array<Object>} collinearity Data from collinearity file
     * @return {undefined}                  undefined
     */
    function generateData(error, gff, collinearity) {
      if (error) return console.error(error);
      collinearityFile = collinearity;

      // For loop to update position dictionary with file data
      for (var i = 0; i < gff.length; i++) {
        // Not including Scaffold chromosomes
        if (gff[i].chrom.startsWith('Scaffold')) continue;
        var start = parseInt(gff[i].start);
        var end = parseInt(gff[i].end);

        if (!(gff[i].chrom in gffPositionDictionary)) {
          gffPositionDictionary[gff[i].chrom] = {};
          gffPositionDictionary[gff[i].chrom].start = start;
        }

        gffPositionDictionary[gff[i].chrom].end = end;
        geneDictionary[gff[i].gene] = {
          start: start,
          end: end
        }
      }

      // Obtaining keys from dictionary and sorting them in ascending order
      gffKeys = Object.keys(gffPositionDictionary);
      gffKeys.sort(function compare(a, b) {
        a = parseInt(a.split('N')[1]);
        b = parseInt(b.split('N')[1]);
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      });

      blockDictionary = {};
      connectionDictionary = {};
      for (var i = 0; i < collinearityFile.length; i++) {
        if (collinearityFile[i].source.includes('N') && collinearityFile[i].target.includes('N')) {
          var currentBlock = collinearityFile[i].block;

          if (!(currentBlock in blockDictionary)) {
            blockDictionary[currentBlock] = [];
          }

          // Adding all the block connections in the dictionary
          blockDictionary[currentBlock].push({
            connection: collinearityFile[i].connection,
            source: collinearityFile[i].source,
            target: collinearityFile[i].target
          });

          var IDs = fixSourceTargetCollinearity(collinearityFile, i);
          var sourceID = IDs.source;
          var targetID = IDs.target;

          // If source is not in the dictionary, create new array for the source
          if (!(sourceID in connectionDictionary)) {
            connectionDictionary[sourceID] = [];
          }

          // If target is not in the dictionary, create new array for the target
          if (!(targetID in connectionDictionary)) {
            connectionDictionary[targetID] = [];
          }

          var indexConnection = 0;
          // If a connection is not found between source and target, then create it
          if (!findBlockConnection(connectionDictionary, sourceID, targetID)) {
            connectionDictionary[sourceID].push({
              blockIDs: [currentBlock],
              connection: targetID,
              connectionAmount: 1
            });
          } else {
            // If a connection is found, then find index, update connection amount,
            // and add new blockID if not present
            indexConnection = findIndexConnection(connectionDictionary, sourceID, targetID);
            connectionDictionary[sourceID][indexConnection].connectionAmount++;

            if (connectionDictionary[sourceID][indexConnection].blockIDs.indexOf(currentBlock) === (-1)) {
              connectionDictionary[sourceID][indexConnection].blockIDs.push(currentBlock);
            }
          }

          // If a connection is not found between target and source, then create it
          if (!findBlockConnection(connectionDictionary, targetID, sourceID)) {
            connectionDictionary[targetID].push({
              blockIDs: [currentBlock],
              connection: sourceID,
              connectionAmount: 1
            });
          } else {
            // If a connection is found, then find index,
            // update connection amount only if not same chromosome,
            // and add new blockID if not present
            var indexConnection = findIndexConnection(connectionDictionary, targetID, sourceID);

            if (targetID != connectionDictionary[targetID][indexConnection].connection) {
              connectionDictionary[targetID][indexConnection].connectionAmount++;
            }

            if (connectionDictionary[targetID][indexConnection].blockIDs.indexOf(currentBlock) === (-1)) {
              connectionDictionary[targetID][indexConnection].blockIDs.push(currentBlock);
            }
          }
        }
      }

      // Determining the block with maximum number of connections
      // (to be used in the filter input range)
      // N13 -> N3 has the max block size with 2295 connections
      var maxBlockSize = 0;
      Object.keys(blockDictionary).forEach(function(d) {
        maxBlockSize = Math.max(maxBlockSize, blockDictionary[d].length);
      });

      // Updating the style of the configuration panel
      d3.select("#config")
        .style("display", "block")
        .style("margin-left", "10px")
        .style("width", width / 3 + "px");

      d3.select("#form-config")
        .append("p")
        .attr("class", "show-all")
        .attr("title", "If selected, all chromosomes will show.")
        .append("input")
        .attr("type", "checkbox")
        .attr("name", "show-all")
        .attr("value", "Show All")
        .property("checked", true); // Show All is checked by default

      d3.select("#form-config").select('p.show-all')
        .append("span")
        .text("Show All");

      d3.select("p.show-all > input")
        .on("change", function() {
          showAllChromosomes = d3.select(this).property("checked");

          // Calling genome view for updates
          generateGenomeView();
        });

      d3.select("#form-config")
        .append("h3")
        .text("Connections");

      d3.select("#form-config")
        .append("h4")
        .attr("class", "block-number-headline")
        .style("font-weight", "normal");

      d3.select("#form-config")
        .append("div")
        .attr("class", "filter-connections-div")
        .append("p")
        .attr("class", "filter-connections")
        .text("Filter:");

      d3.select(".filter-connections-div")
        .append("p")
        .attr("class", "filter-connections")
        .append("select")
        .html(function() {
          return '<option value="At Least">At Least</option><option value="At Most">At Most</option>';
        });

      d3.select(".filter-connections-div")
        .select("select")
        .on("change", function() {
          filterSelect = d3.select(this).property("value");

          // Calling path genome view for updates
          generatePathGenomeView();
        });

      d3.select(".filter-connections-div")
        .append("p")
        .attr("class", "filter-connections")
        .html(function() {
          return '<label for="filter" style="display: inline-block; text-align: left; width: 115px">' +
            '<span id="filter-value">...</span>' +
            '</label>';
        });

      d3.select(".filter-connections-div")
        .append("p")
        .attr("class", "filter-connections")
        .html(function() {
          return '<input style="margin-left: 45px; width: 195px" type="range" min="1" max=' +
            maxBlockSize.toString() + ' id="filter">';
        });

      d3.select("#form-config").selectAll("p:not(.show-all):not(.filter-connections)")
        .data(gffKeys).enter()
        .append("p")
        .append("input")
        .attr("class", "chr-box")
        .attr("type", "checkbox")
        .attr("name", function(d) {
          return d;
        })
        .attr("value", function(d) {
          return d;
        });

      d3.select("#form-config").selectAll(".chr-box")
        .data(gffKeys)
        .on("change", function() {
          selectedCheckbox = [];
          var selectedChromosomes = [];
          var visitedChr = {}; // Visited chromosomes dictionary
          for (var i = 0; i < gffKeys.length; i++) {
            visitedChr[gffKeys[i]] = false;
          }

          d3.selectAll(".chr-box").each(function(d) {
            d3.select(this.parentNode).classed("disabled", false);
            d3.select(this.parentNode).select("span").text(d);

            var cb = d3.select(this);
            cb.attr("disabled", null);
            if (cb.property("checked")) {
              // If chromosome is already checked, then it is visited
              visitedChr[d] = true;
              selectedChromosomes.push(cb.property("value"));
              selectedCheckbox.push(cb.property("value"));
            }
          });

          // Changing Select/Deselect All button depending on the amount of selected chromosomes
          if (selectedChromosomes.length == 0) {
            d3.select(".select-all > input").property("value", "Select All");
            d3.select("p.select-all").attr("title", "Selects all the connections.");
          } else {
            d3.select(".select-all > input").property("value", "Deselect All");
            d3.select("p.select-all").attr("title", "Deselects all the connections.");
          }

          if (selectedChromosomes.length == 1) {
            // If only one chromosome is selected, the connection information will show
            // for each other chromosome

            for (var j = 0; j < gffKeys.length; j++) {
              // If a connection is found, mark current chromosome as visited
              if (findBlockConnection(connectionDictionary, selectedChromosomes[0], gffKeys[j])) {
                visitedChr[gffKeys[j]] = true;
              }
            }

            d3.selectAll(".chr-box").each(function(d) {
              d3.select(this.parentNode).select('span').html(function() {
                // Finding the index of the connection in the dictionary
                var indexConnection = findIndexConnection(connectionDictionary, selectedChromosomes[0], d);
                var connectionAmount = 0;
                var textToShow = d;
                var style = '<em style="display: inline-block; text-align: right; width: 65px; margin-left: 10px">';
                if (indexConnection === (-1)) {
                  textToShow += style + '0 blocks' + ' </em>';
                } else {
                  connectionAmount = connectionDictionary[selectedChromosomes[0]][indexConnection].blockIDs.length;
                  if (connectionAmount === 1) {
                    textToShow += style + connectionAmount.toString() + ' block' + ' </em>';
                  } else {
                    textToShow += style + connectionAmount.toString() + ' blocks' + ' </em>';
                  }
                }

                return textToShow;
              });

              if (visitedChr[d]) {
                d3.select(this).attr("disabled", null);
                d3.select(this.parentNode).classed("disabled", false);
              } else {
                // Only disable not visited chromosomes
                d3.select(this).attr("disabled", "true");
                d3.select(this.parentNode).classed("disabled", true);
              }
            });
          }

          // Calling genome view for updates
          generateGenomeView();
        });

      d3.select("#form-config").selectAll("p:not(.show-all):not(.filter-connections)")
        .append("span")
        .text(function(d) {
          return d;
        });

      d3.select("#form-config")
        .append("p")
        .attr("class", "select-all")
        .attr("title", "Selects all the connections.")
        .append("input")
        .attr("type", "button")
        .attr("value", "Select All");

      d3.select("#form-config")
        .select(".select-all > input")
        .on("click", function() {
          if (d3.select(this).property("value") == "Select All") {
            // Changing the value and title to Deselect All
            d3.select(this).property("value", "Deselect All");
            d3.select("p.select-all").attr("title", "Deselects all the connections.");

            // Selecting all checkboxes
            d3.selectAll(".chr-box").each(function() {
              if (!d3.select(this).property("checked")) {
                d3.select(this).property("checked", true);
                selectedCheckbox.push(d3.select(this).property("value"));
              }
            });
          } else {
            // Changing the value and title to Select All
            d3.select(this).property("value", "Select All");
            d3.select("p.select-all").attr("title", "Selects all the connections.");

            // All checkboxes are returned to their original state
            d3.selectAll(".chr-box").each(function(d) {
              d3.select(this.parentNode).classed("disabled", false);
              d3.select(this.parentNode).select("span").text(d);

              var cb = d3.select(this);
              cb.attr("disabled", null);
              if (d3.select(this).property("checked")) {
                d3.select(this).property("checked", false);
              }
            });

            selectedCheckbox = [];
          }

          // When Select/Deselect All is clicked, all chromosomes will show by default
          showAllChromosomes = true;
          d3.select(".show-all > input").property("checked", true);

          // Calling genome view for updates
          generateGenomeView();
        });

      // SVG element that will include the circos plot
      svg = d3.select("body")
        .append("div")
        .attr("id", "chart")
        .attr("width", width)
        .attr("height", height)
        .style("float", "left")
        .style("margin-top", "50px");

      // Loading the circos plot in the svg element
      myCircos = new Circos({
        container: '#chart',
        width: width,
        height: height
      });

      // Updating angle on input
      d3.select("#nAngle")
        .on("input", function() {
          updateAngle(+this.value);
        });

      // Initial starting angle of the text
      updateAngle(chromosomeRotateAngle);

      // Updating filter on input
      d3.select("#filter")
        .on("input", function() {
          updateFilter(+this.value, true);
        });

      // Default filtering
      updateFilter(filterValue, false);

      generateGenomeView();
    }

    /**
     * Generates block view for the current highlighted block in the genome view
     *
     * @param  {Object} data Current data with all source and target chromosome
     *                       information
     * @return {undefined}   undefined
     */
    function generateBlockView(data) {
      var sourceChromosomeID = data.source.id;
      var targetChromosomeID = data.target.id;
      var blockID = data.source.value.id;

      var margin = {
        top: 50,
        right: 90,
        bottom: 50,
        left: 90
      };
      var widthBlock = 500 - margin.left - margin.right;
      var heightBlock = 800 - margin.top - margin.bottom;

      // Set the ranges for x and y
      var y = [d3.scaleLinear().range([heightBlock, 0]), d3.scaleLinear().range([heightBlock, 0])];

      var x = d3.scalePoint().rangeRound([0, widthBlock]);
      var dimensions = [0, 1];
      x.domain(dimensions);

      var line = d3.line();

      /**
       * Defines the path for each data point in the block view
       *
       * d3 is looping through each data array
       * i can be either 0 or 1 (the dimensions),
       * thus dataArray[i] is the value for each dimension in the current array
       * y[i](dataArray[i]) is scaling the current value in the dimension
       *
       * @param  {Array<number>}   dataArray Current dataArray with [y0, y1] coordinates
       * @param  {Array<Function>} y         Current array of y scales
       * @return {Array<number>}             Current path line defined with the
       *                                     points [x0, projectionOfY0] and
       *                                     [x1, projectionOfY1]
       */
      function path(dataArray, y) {
        dataArray = dataArray.data;
        return line(dimensions.map(function(i) {
          return [x(i), y[i](dataArray[i])];
        }));
      }

      // Remove block view if it is present
      if (!d3.select("body").select("#block-view-container").empty()) {
        d3.select("body").select("#block-view-container").remove();
      }

      var gY0, gY1, y0axis, y1axis, isFlipped = false;
      var dataBlock = [];

      /**
       * Flips the data for the current block view
       *
       * @param  {Array<Object>} dataBlock Current block data array
       * @return {Array<Object>}           Flipped array
       */
      function flipTargetDataBlock(dataBlock) {
        var index = 1; // Flipping target by default
        var temp = 0;
        var tempArray = _.cloneDeep(dataBlock);

        for (var i = 0; i < tempArray.length / 2; i++) {
          temp = tempArray[i].data[index];
          tempArray[i].data[index] = tempArray[tempArray.length - i - 1].data[index];
          tempArray[tempArray.length - i - 1].data[index] = temp;
        }

        return tempArray;
      }

      /**
       * Determines if an array is perfectly flipped or not
       *
       * @param  {Array<Object>}  dataBlock Current block data array
       * @return {boolean}                  True if array is perfectly flipped,
       *                                    false otherwise
       */
      function isPerfectlyFlipped(dataBlock) {
        var tempArray = _.cloneDeep(dataBlock);
        var numericGeneArray = [];

        for (var i = 0; i < tempArray.length; i++) {
          numericGeneArray.push(parseInt(tempArray[i].target.id.split('g')[1].split('.')[0]));
        }

        var isDescending = true;

        for (var i = 0; i < numericGeneArray.length - 1; i++) {
          if (numericGeneArray[i] < numericGeneArray[i + 1]) {
            isDescending = false;
            break;
          }
        }

        return isDescending;
      }

      // Append block view container to the body of the page
      d3.select("body").append("div")
        .attr("id", "block-view-container")
        .style("float", "left")
        .style("margin-left", "50px")
        .style("margin-top", "50px");

      d3.select("#block-view-container")
        .append("button")
        .style("position", "absolute")
        .attr("title", "Resets the block view to its original scale.")
        .text("Reset")
        .on("click", function() {
          // Resetting by calling path block view
          generatePathBlockView(dataBlock);
        });

      var svgBlock = d3.select("#block-view-container")
        .append("svg")
        .attr("class", "block-view")
        .attr("width", widthBlock + margin.left + margin.right)
        .attr("height", heightBlock + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      d3.select("#block-view-container")
        .append("p")
        .style("text-align", "right")
        .style("margin", "-40px 30px 0 0")
        .append("input")
        .attr("class", "flip-orientation")
        .attr("type", "checkbox")
        .attr("name", "flip-orientation")
        .attr("value", "flip-orientation")
        .property("checked", false);

      d3.select("#block-view-container")
        .select("p")
        .append("span")
        .text("Flip Orientation");

      d3.select("#block-view-container")
        .append("p")
        .attr("class", "flip-hint")
        .style("display", "none")
        .style("margin-top", "10px")
        .html(function() {
          return '<em>Hint: This block is perfectly inverted.</em>';
        });

      d3.select("#block-view-container")
        .select(".flip-orientation")
        .on("change", function() {
          dataBlock = flipTargetDataBlock(dataBlock);
          isFlipped = d3.select(this).property("checked");

          // Calling path block view for updates
          generatePathBlockView(dataBlock);
        });

      // Rectangle that has the block view size to catch any zoom event
      var zoomView = svgBlock.append("rect")
        .attr("width", widthBlock)
        .attr("height", heightBlock)
        .style("fill", "none")
        .style("pointer-events", "all");

      // Defining a clip-path so that lines always stay inside the block view,
      // thus paths will be clipped when zooming
      var clip = svgBlock.append("defs").append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("id", "clip-rect")
        .attr("x", "0")
        .attr("y", "0")
        .attr("width", widthBlock)
        .attr("height", heightBlock);

      // Zoom behavior
      var zoom = d3.zoom()
        .scaleExtent([0.01, 100])
        .on("zoom", function() {
          if (gY0 && gY1) {
            var zoomTransform = d3.event.transform;

            // Rescaling axes using current zoom transform
            gY0.call(y0axis.scale(zoomTransform.rescaleY(y[0])));
            gY1.call(y1axis.scale(zoomTransform.rescaleY(y[1])));

            // Creating new scales (y0, y1) that incorporate current zoom transform
            var newY = [zoomTransform.rescaleY(y[0]), zoomTransform.rescaleY(y[1])];

            // Plotting the lines path using the new scales
            svgBlock.selectAll("path")
              .data(dataBlock)
              .attr("d", function(data) {
                return path(data, newY);
              })
          }
        });

      var blockArray = blockDictionary[blockID];
      for (var i = 0; i < blockArray.length; i++) {
        var blockSource = blockArray[i].source;
        var blockTarget = blockArray[i].target;
        var currentSource = geneDictionary[blockSource];
        var currentTarget = geneDictionary[blockTarget];

        // Points are the determined using the midpoint between start and end
        var currentData = [
          (currentSource.start + currentSource.end) / 2,
          (currentTarget.start + currentTarget.end) / 2
        ];

        dataBlock.push({
          source: {
            id: blockSource,
            start: currentSource.start,
            end: currentSource.end
          },
          target: {
            id: blockTarget,
            start: currentTarget.start,
            end: currentTarget.end
          },
          data: currentData
        });
      }

      // Numeric scale used for the stroke-width of each line path in the block
      var strokeWidthScale = d3.scaleQuantize()
        .domain([
          d3.min(dataBlock, function(d) {
            return (d.source.end - d.source.start) + (d.target.end - d.target.start);
          }),
          d3.max(dataBlock, function(d) {
            return (d.source.end - d.source.start) + (d.target.end - d.target.start);
          })
        ])
        .range([1, 2, 3, 4, 5]);

      /**
       * Generates all paths in the blockView using the current selected
       * block in the genomeView
       *
       * @param  {Array<Object>} dataBlock Current block data array
       * @return {undefined}               undefined
       */
      function generatePathBlockView(dataBlock) {
        // Calling zoom for the block, so it works for every path
        svgBlock.call(zoom)
          .call(zoom.transform, d3.zoomIdentity.scale(1));

        var d3Element = d3.select("#block-view-container")
          .select(".flip-hint");

        if (!isFlipped) {
          if (isPerfectlyFlipped(dataBlock)) {
            // If flip orientation is not selected, and the data block is perfectly
            // flipped, then show hint (display block)
            d3Element.style("display", "block");
          }
        } else {
          d3Element.style("display", "none");
        }

        /**
         * Determines the minimum value in the current block scale
         *
         * @param  {number} d The number of the scale: y0 or y1
         * @return {number}   Minimum value
         */
        function minData(d) {
          var minValue = 100000000;
          for (var i = 0; i < dataBlock.length; i++) {
            minValue = Math.min(minValue, dataBlock[i].data[d]);
          }
          return minValue;
        }

        /**
         * Determines the maximum value in the current block scale
         *
         * @param  {number} d The number of the scale: y0 or y1
         * @return {number}   Maximum value
         */
        function maxData(d) {
          var maxValue = 0;
          for (var i = 0; i < dataBlock.length; i++) {
            maxValue = Math.max(maxValue, dataBlock[i].data[d]);
          }
          return maxValue;
        }

        // Offset to be used for the scales domain
        var offset = 50000;

        // Y scale domains using minimum, maximum and offset values
        y[0].domain([minData(0) - offset, maxData(0) + offset]);
        y[1].domain([minData(1) - offset, maxData(1) + offset]);

        // Remove old paths if they are present
        if (!svgBlock.selectAll("path.line").empty()) {
          svgBlock.selectAll("path.line").remove();
        }

        // Add new paths inside the block
        svgBlock.append("g").attr("clip-path", "url(#clip)")
          .selectAll("path")
          .data(dataBlock).enter()
          .append("path")
          .attr("class", "line")
          .attr("d", function(data) {
            return path(data, y);
          })
          .attr("stroke", connectionColor)
          .attr("stroke-width", function(d) {
            // Returning stroke-width based on defined scale
            return strokeWidthScale(
              (d.source.end - d.source.start) + (d.target.end - d.target.start)
            );
          })
          .append("title") // Being used as simple tooptip
          .text(function(d) {
            return d.source.id + ' ➤ ' + d.target.id;
          });

        svgBlock.selectAll("path")
          .on("mouseover", function(d, i, nodes) {
            if (d3.selectAll(nodes).attr("opacity") != 0.35) {
              d3.selectAll(nodes).attr("opacity", 0.35);
              d3.select(nodes[i]).attr("opacity", 1);
            }
          })
          .on("mouseout", function(d, i, nodes) {
            if (d3.selectAll(nodes).attr("opacity") != 1) {
              d3.selectAll(nodes).attr("opacity", 1);
            }
          });

        // Add the Y0 Axis
        y0axis = d3.axisLeft(y[0]).tickSize(15);

        // Remove axisY0 if it is present
        if (!svgBlock.selectAll("g.axisY0").empty()) {
          svgBlock.selectAll("g.axisY0").remove();
        }

        gY0 = svgBlock.append("g")
          .attr("class", "axisY0")
          .call(y0axis.ticks(10))
          .attr("fill", function() {
            return colors(parseInt(sourceChromosomeID.split('N')[1]) - 1);
          });

        // Add the Y1 Axis
        y1axis = d3.axisRight(y[1]).tickSize(15);

        // Remove axisY1 if it is present
        if (!svgBlock.selectAll("g.axisY1").empty()) {
          svgBlock.selectAll("g.axisY1").remove();
        }

        gY1 = svgBlock.append("g")
          .attr("class", "axisY1")
          .attr("transform", "translate( " + widthBlock + ", 0 )")
          .call(y1axis.ticks(10))
          .attr("fill", function() {
            return colors(parseInt(targetChromosomeID.split('N')[1]) - 1);
          });
      }

      generatePathBlockView(dataBlock);

      // Add the Y0 Axis label text
      svgBlock.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x", 0 - (heightBlock / 2))
        .attr("dy", "1em")
        .style("font-size", "16px")
        .style("text-anchor", "middle")
        .text(sourceChromosomeID);

      // Add the Y1 Axis label text
      svgBlock.append("text")
        .attr("transform", "rotate(90)")
        .attr("y", 0 - widthBlock - margin.right)
        .attr("x", (heightBlock / 2))
        .attr("dy", "1em")
        .style("font-size", "16px")
        .style("text-anchor", "middle")
        .text(targetChromosomeID);

      // Add the Chart title
      svgBlock.append("text")
        .attr("x", (widthBlock / 2))
        .attr("y", 0 - (margin.top / 3))
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .style("text-decoration", "underline")
        .text(sourceChromosomeID + ' vs. ' + targetChromosomeID + ' - Block ' + blockID + ' gene locations');
    }

    /**
     * Generates all genomes using the current selected chromosomes
     *
     * @return {undefined} undefined
     */
    function generateGenomeView() {
      // Remove block view if it is present
      if (!d3.select("body").select("#block-view-container").empty()) {
        d3.select("body").select("#block-view-container").remove();
      }

      dataChromosomes = [];

      // Using gffKeys array to add selected chromosomes to the genome view
      gffKeys.forEach(function(key, i) {
        if (gffPositionDictionary.hasOwnProperty(key)) {
          var currentObj = {
            len: gffPositionDictionary[key].end,
            color: colors(i),
            label: key,
            id: key
          };

          if (showAllChromosomes) {
            // All the chromosomes will show
            dataChromosomes.push(currentObj);
          } else {
            if (selectedCheckbox.indexOf(key) > -1) {
              // If current chromosome is selected and showAllChromosomes is
              // not selected, then add it
              dataChromosomes.push(currentObj);
            }
          }
        }
      });

      // Generating layout configuration for the circos plot
      myCircos.layout(dataChromosomes, {
        innerRadius: 300,
        outerRadius: 350,
        cornerRadius: 1,
        gap: dataChromosomes.length === 1 ? 0 : 0.04, // Value in radian
        labels: {
          display: true,
          position: 'center',
          size: '16px',
          color: '#000000',
          radialOffset: 20
        },
        ticks: {
          display: false
        }
      });

      generatePathGenomeView();
    }

    // Call generateData only after loading the data files
    d3.queue()
      .defer(d3.csv, './files/gff.csv')
      .defer(d3.csv, './files/collinearity.csv')
      .await(generateData)
  </script>
</body>

</html>
